{
"title": "从逆向角度学Intel_x86_汇编",
"top": true,
"toc": true,
"category": "汇编语言",
"tags":["x86","汇编语言"],
"preview": "重点在理解程序运行的环境，学会常见指令的功能。穿插一些x32dbg和visual studio的使用方法。"
}
---
# x32dbg使用方法
- 打开一个exe可执行程序后断点在系统函数。通过点击run命令自动执行到用户程序的入口函数。
- x32dbg的栈窗口会跟随栈顶值变化
# 数字电路基础知识
理解补码，反码，原码关键在于这是三种编码方式，而非数值。原码只是恰好和二进制对应的十进制数的规则相同。\
计算电路就是按照原码来设计的，在需要计算负数时，通过改变编码方式实现，而不是通过改变电路。\
已知有符号数的补码求对应的十进制数：\
1. 先将所有位取反
2. 取反后的二进制数加1
3. 转换成对应的十进制，加上负号。
已知一个负十进制数，求对应的有符号数的表示（即补码）
1. 将绝对值转成二进制
2. 将所有位取反包括最高位
3. 将取反后的二进制加一
# MOV指令
指令格式：操作码 （目标）操作数，（源）操作数\
两个操作数的数据宽度必须一致。
## 寄存器
一共8个32位通用寄存器。EAX（accumulator）,ECX（counter）,EDX（data）,EBX（base address）,EBP(base address pointer),ESP(stack top pointer),ESI(source index),EDI（destination index）。\
8个16位寄存器。\
8个8位寄存器。\
需要注意8位寄存器并不是直接截断全部8个的32位寄存器，而是拆分的前4个16位寄存器。
## 指令语法
 - mov r/m8, r8
 - mov r/m16, r16
 - mov r/m32, r32
 - mov r8, r/m8
 - mov r16, r/m16
 - mov r32, r/m32
 - mov r8, imm8
 - mov r16, imm16
 - mov r32, imm32
# ADD指令
见intel编程手册第二卷第三章\
可以操作的对象只可能是寄存器，内存地址，立即数。
# SUB指令
# AND指令
# OR指令
# XOR指令
# NOT指令
# 向内存中写数据
前提条件：认识运行中的内存。\
每个32位x86程序运行时，操作系统会为其分配4G的虚拟空间。但是不能全部使用，其中有正在运行的系统库指令，程序的数据区，程序的指令区。因此不是所有的地址都具有读写权限。
# 内存寻址的5种方式
## 立即数直接寻址
值的宽度 ptr ds:[立即数]
### LEA 指令
将指定的内存地址写到某个寄存器（目标操作数只能是寄存器），用法：\
`lea eax, DWORD PTR DS:[12FFC4]`\
结果：12FFC4\
`lea eax, DWORD ptr ds:[ecx]`\
结果：eax的值会等于ecx的值。
## 寄存器直接寻址[reg]
值的宽度 ptr ds:[reg8/16/32]
## 寄存器表达式寻址[reg+立即数]， [reg + reg*{1,2,4,8}]只能是{1,2,4,8}，[reg+reg*{1,2,4,8}+立即数]
# 引入栈结构
【栈结构更像气球，而不是竹筒】\
需求：
- 需要临时存储一些数据，但是数量比较多，不能全放在寄存器中。(用内存)
- 能够记录存了多少数据。（使用两个寄存器保存一段连续的内存地址两端，简单计算即可得到一共记录的数据个数）
- 能够快速找到某个数据（大的内存地址减去偏移值即可定位到目标值或者小的地址加上偏移值）
这时需要利用内存设计某种机制，来满足2，3需求。\
windows分配栈的时候从高地址向低地址分配。\
模拟栈结构的操作：\

``` mov ebx,EFFC68  ；初始化栈结构，即给栈顶和栈底赋值。
  mov edx,EFFC68

  mov dword ptr ds:[edx-4],AAAAAAAA  ；使用栈存值，分两步，先写值再更改栈顶指针
  sub edx,4

  nop
  lea edx,dword ptr ds:[edx-4]       ；存值，先修改栈顶指针，再存值
  mov dword ptr ds:[edx],BBBBBBBB

  mov esi,dword ptr ds:[ebx-8]    ;取出想要保存的值，可以从栈底开始也可以从栈顶开始加偏移值。
  ```
## 栈使用的一般流程：
- 使用两个寄存器分别存栈底和栈顶地址（初始状态栈顶和栈底地址相同）
- 连续存储若干个数
- 使用栈顶或栈底偏移的方式读取这些数，读取到寄存器中
- 移动（表示一步一步的过程，而非直接设置）栈顶指针到栈底，
## ESP,EBP
在需要使用栈结构时ESP（stack top pointer）存储栈顶值，EBP（base address pointer）。\
## push指令
详见intel编程手册卷二第三章。\
push可以看成做两个动作：向上移动（减法）栈顶指针，将数据写到原来的栈顶处。二者没有先后关系。\
push imm8/16/32，ESP总是减少4个字节的地址长度。\
push r16/32，push 不能操作八位寄存器。\
push m16/32, m16时ESP减少2个字节的地址长度。
## pop指令
pop可以看成做了两个动作：向下移动（加法）栈顶指针，将原来栈顶位置的数，读取并写到指令的寄存器。
## pushad和popad指令
对八个通用寄存器的整体操作，但是不影响原来存在栈中的数据。
# 标志寄存器
详见intel编程手册第一卷第三章。\
## CF(carry flag)
如果（算术和逻辑运算）运算结果最高位产生了一个进位或借位，其值为1，否则其值为0。\
## PF（parity flag）
（算术和逻辑运算）结果里面1的个数，偶数为1，奇数为0
## AF(Auxiliary Carry flag)
（算术和逻辑运算）辅助进位标志，在下列情况被置为1，其余为0：\
- 在字操作时，发生低字节向高字节进位或借位。
- 在字节操作时，发生低4位向高4位进位或借位。
`
mov eax, 0x55eeffff
add eax,2

mov ax, 5efe
add ax,2

mov al,4e
add al,2
`
## ZF（zero flag）
（算术和逻辑）运算结果是否为0，无论数据宽度。\
## SF （sign flag）
用来表示运算结果的符号位（和运算结果的符号位相同，即与运算结果的最高位相同），\
`
mov al,7f
add al,2
`
溢出标志位OF和SF与CF区别：\
正数与负数相加永远不会溢出，7f（最大正数）+ff（最大负数）= 17e\
## Of(overflow flag)
溢出标志位。\
什么是溢出？溢出标志位和CF位很像，CF是做无符号运算时应该关注的寄存器。OF是做有符号运算关注的，只要涉及有符号运算只需要关注OF位是否溢出即可。\
###  溢出的概念只存在于有符号运算中（即当你认为两个操作数按照有符号数编码时）
- 正数+ 正数 = 正（小于7f）不溢出，如果结果大于7f（为负数）溢出。