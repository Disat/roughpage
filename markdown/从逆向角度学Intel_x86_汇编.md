{
"title": "从逆向角度学Intel_x86_汇编",
"top": true,
"toc": true,
"category": "汇编语言",
"tags":["x86","汇编语言"],
"preview": "重点在理解程序运行的环境，学会常见指令的功能。穿插一些x32dbg和visual studio的使用方法。"
}
---
# x32dbg使用方法
- 打开一个exe可执行程序后断点在系统函数。通过点击run命令自动执行到用户程序的入口函数。
# MOV指令
指令格式：操作码 （目标）操作数，（源）操作数\
两个操作数的数据宽度必须一致。
## 寄存器
一共8个32位通用寄存器。EAX,ECX,EDX,EBX,EBP,ESP,ESI,EDI。\
8个16位寄存器。\
8个8位寄存器。\
需要注意8位寄存器并不是直接截断全部8个的32位寄存器，而是拆分的前4个16位寄存器。
## 指令语法
 - mov r/m8, r8
 - mov r/m16, r16
 - mov r/m32, r32
 - mov r8, r/m8
 - mov r16, r/m16
 - mov r32, r/m32
 - mov r8, imm8
 - mov r16, imm16
 - mov r32, imm32
# ADD指令
见intel编程手册第二卷第三章\
可以操作的对象只可能是寄存器，内存地址，立即数。
# SUB指令
# AND指令
# OR指令
# XOR指令
# NOT指令
# 向内存中写数据
前提条件：认识运行中的内存。\
每个32位x86程序运行时，操作系统会为其分配4G的虚拟空间。但是不能全部使用，其中有正在运行的系统库指令，程序的数据区，程序的指令区。因此不是所有的地址都具有读写权限。
# 内存寻址的5种方式
## 立即数直接寻址
值的宽度 ptr ds:[立即数]
### LEA 指令
将指定的内存地址写到某个寄存器（目标操作数只能是寄存器），用法：\
`lea eax, DWORD PTR DS:[12FFC4]`\
结果：12FFC4\
`lea eax, DWORD ptr ds:[ecx]`\
结果：eax的值会等于ecx的值。
## 寄存器直接寻址[reg]
值的宽度 ptr ds:[reg8/16/32]
## 寄存器表达式寻址[reg+立即数]， [reg + reg*{1,2,4,8}]只能是{1,2,4,8}，[reg+reg*{1,2,4,8}+立即数]
# 引入栈结构
【栈结构更像气球，而不是竹筒】\
需求：
- 需要临时存储一些数据，但是数量比较多，不能全放在寄存器中。(用内存)
- 能够记录存了多少数据。（使用两个寄存器保存一段连续的内存地址两端，简单计算即可得到一共记录的数据个数）
- 能够快速找到某个数据（大的内存地址减去偏移值即可定位到目标值或者小的地址加上偏移值）
这时需要利用内存设计某种机制，来满足2，3需求。\
windows分配栈的时候从高地址向低地址分配。\
模拟栈结构的操作：\

` mov ebx,EFFC68  ；初始化栈结构，即给栈顶和栈底赋值。
  mov edx,EFFC68

  mov dword ptr ds:[edx-4],AAAAAAAA  ；使用栈存值，分两步，先写值再更改栈顶指针
  sub edx,4

  nop
  lea edx,dword ptr ds:[edx-4]       ；先修改栈顶指针，再存值
  mov dword ptr ds:[edx],BBBBBBBB
  `